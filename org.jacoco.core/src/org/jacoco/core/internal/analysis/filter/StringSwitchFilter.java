/*******************************************************************************
 * Copyright (c) 2009, 2017 Mountainminds GmbH & Co. KG and Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Evgeny Mandrikov - initial API and implementation
 *
 *******************************************************************************/
package org.jacoco.core.internal.analysis.filter;

import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LookupSwitchInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TableSwitchInsnNode;

/**
 * Filters code that is generated for a switch statement with a String.
 */
public final class StringSwitchFilter implements IFilter {

	public void filter(final String className, final String superClassName,
			final MethodNode methodNode, final IFilterOutput output) {
		AbstractInsnNode i = methodNode.instructions.getFirst();
		while (i != null) {
			if (isStringSwitchStart(i)) {
				filterStringSwitch(i, output);
			}
			i = i.getNext();
		}
	}

	/**
	 * @return next instruction that is not frame
	 */
	private static AbstractInsnNode nextInstructionSkipFrames(
			AbstractInsnNode i) {
		do {
			i = i.getNext();
		} while (i.getType() == AbstractInsnNode.FRAME);
		return i;
	}

	/**
	 * Returns <code>true</code> if given instruction is {@code LOOKUPSWITCH} or
	 * {@code TABLESWITCH} preceded by
	 * {@code INVOKEVIRTUAL java/lang/String.hashCode ()I}.
	 */
	private static boolean isStringSwitchStart(
			final AbstractInsnNode instruction) {
		if (instruction.getOpcode() == Opcodes.LOOKUPSWITCH
				|| instruction.getOpcode() == Opcodes.TABLESWITCH) {
			final AbstractInsnNode previous = instruction.getPrevious();
			if (previous.getOpcode() == Opcodes.INVOKEVIRTUAL) {
				final MethodInsnNode m = ((MethodInsnNode) previous);
				return "java/lang/String".equals(m.owner)
						&& "hashCode".equals(m.name);
			}
		}
		return false;
	}

	/**
	 * Filters code that is generated for String in switch statement (Java 7).
	 *
	 * Code generated by javac is easy to filter - everything up to a final
	 * switch should be ignored:
	 *
	 * <pre>
	 *     LOOKUPSWITCH
	 *     h1: ...
	 *     IFEQ h1_2
	 *     ...
	 *     h1_2: ...
	 *     IFEQ after_h
	 *     ...
	 *     GOTO after_h
	 *     h2: ...
	 *     IFEQ after_h
	 *     after_h:
	 *     TABLESWITCH
	 *     c1: ...
	 *     c2: ...
	 *     c3: ...
	 *     default: ...
	 * </pre>
	 * 
	 * Code generated by ECJ is more tricky to handle, because it contains only
	 * one switch:
	 *
	 * <pre>
	 *     LOOKUPSWITCH  // or TABLESWITCH
	 *     h1: ...
	 *     IFNE c1
	 *     ...
	 *     IFNE c2
	 *     GOTO default
	 *     h2: ...
	 *     IFNE c2
	 *     GOTO default  // won't appear if default case is a first one
	 *     c1: ...
	 *     c2: ...
	 *     c3: ...
	 *     default: ...
	 * </pre>
	 */
	private static void filterStringSwitch(final AbstractInsnNode start,
			final IFilterOutput output) {
		boolean javac = true;
		AbstractInsnNode i = start;

		final LabelNode dflt;
		final int hashCodes;
		if (i.getOpcode() == Opcodes.LOOKUPSWITCH) {
			dflt = ((LookupSwitchInsnNode) i).dflt;
			hashCodes = ((LookupSwitchInsnNode) i).labels.size();
		} else {
			dflt = ((TableSwitchInsnNode) i).dflt;
			hashCodes = ((TableSwitchInsnNode) i).labels.size();
		}
		i = i.getNext();
		for (int h = 0; h < hashCodes; h++) {
			output.ignoreJumpTarget(nextInstructionSkipFrames(i));
			do {
				if (i.getOpcode() == Opcodes.IFNE) {
					javac = false;
					output.remapJump(i, start);
				}
				i = i.getNext();
			} while (i.getType() != AbstractInsnNode.LABEL);
			output.ignore(start.getNext(), i.getPrevious());
		}

		if (javac) {
			output.ignore(start, dflt.getPrevious());
		}
	}

}
