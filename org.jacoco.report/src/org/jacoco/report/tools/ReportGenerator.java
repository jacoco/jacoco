/*******************************************************************************
 *  Copyright (c) 2009, 2016 Mountainminds GmbH & Co. KG and Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Omer Azmon - initial API and implementation
 *    
 *******************************************************************************/
package org.jacoco.report.tools;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

import org.jacoco.core.analysis.CoverageBuilder;
import org.jacoco.core.analysis.IAnalyzer;
import org.jacoco.core.analysis.IBundleCoverage;
import org.jacoco.core.tools.DefaultCoverageFetcherStyle;
import org.jacoco.core.tools.ICoverageFetcherStyle;
import org.jacoco.core.tools.LoggingBridge;
import org.jacoco.ebigo.core.WorkloadAttributeMapBuilder;
import org.jacoco.ebigo.tools.EBigOCoverageFetcherStyle;
import org.jacoco.report.FileMultiReportOutput;
import org.jacoco.report.IReportVisitor;
import org.jacoco.report.ISourceFileLocator;
import org.jacoco.report.MultiReportVisitor;
import org.jacoco.report.csv.CSVFormatter;
import org.jacoco.report.html.HTMLFormatter;
import org.jacoco.report.xml.XMLFormatter;

/**
 * A Tool to generate coverage/ebigo reports. Any report is generated in all
 * three formats: HTML, XML, and CSV. To generate a report using the default
 * values use the <code>execute</code> method.
 * <p>
 * Default Values:
 * <ul>
 * <li>Locale = default Java Locale
 * <li>Bundle Name = "JaCoCo Test"
 * <li>Source Encoding = "UTF-8"
 * <li>Source Root Directories = {"src/main/java"}
 * <li>Report Output Encoding = "UTF-8"
 * <li>Report Output Directory = "target/site/jacoco"
 * <li>Class Root Directories = {"target/classes"}
 * <li>E-BigO Attribute = <code>null</code> (i.e. E-BigO disabled)
 * </ul>
 */
public abstract class ReportGenerator {

	private static final String NAME = "JaCoCo Test";
	private static final String DEFAULT_ENCODING = "UTF-8";
	private static final File DEFAULT_OUTPUT_DIR = new File(
			"target/site/jacoco");
	private static final List<File> DEFAULT_SOURCE_DIR = Arrays
			.asList(new File[] { new File("src/main/java") });
	private static final List<File> DEFAULT_CLASSES_DIRECTORIES = Arrays
			.asList(new File("target/classes"));

	private final LoggingBridge log;

	private String name = NAME;
	private String outputEncoding = DEFAULT_ENCODING;
	private String sourceEncoding = DEFAULT_ENCODING;
	private File reportOutputDirectory = DEFAULT_OUTPUT_DIR;
	private boolean eBigOEnabled = false;
	private String eBigOAttribute = null;
	private List<File> sourceRoots = DEFAULT_SOURCE_DIR;
	private Locale locale = Locale.getDefault();
	private List<File> classesDirectories = DEFAULT_CLASSES_DIRECTORIES;

	private ICoverageFetcherStyle dataFetcher;

	/**
	 * Construct the report generator with logging to standard out.
	 */
	public ReportGenerator() {
		this.log = new DirectLoggingBridge();
	}

	/**
	 * Construct the report generator.
	 * 
	 * @param log
	 *            a logging bridge to use for any log message generated by the
	 *            report generator
	 */
	public ReportGenerator(final LoggingBridge log) {
		this.log = log;
	}

	/**
	 * Provide subclasses with access to the logging bridge.
	 * 
	 * @return the logging bridge.
	 */
	protected LoggingBridge getLog() {
		return this.log;
	}

	/**
	 * Returns the report bundle name used in the report output.
	 * 
	 * @return the report bundle name used in the report output.
	 */
	public final String getName() {
		return name;
	}

	/**
	 * Sets the report bundle name used in the report output.
	 * 
	 * @param name
	 *            the new report bundle.If <code>null</code> returns to the
	 *            default value. See class description for defaults.
	 * @return this object. For method chaining.
	 */
	public final ReportGenerator setName(final String name) {
		this.name = name == null ? NAME : name;
		return this;
	}

	/**
	 * Returns the source encoding used.
	 * 
	 * @return the source encoding used.
	 */
	public final String getSourceEncoding() {
		return sourceEncoding;
	}

	/**
	 * Sets the source encoding used..
	 * 
	 * @param sourceEncoding
	 *            the new source encoding. If <code>null</code> returns to the
	 *            default value. See class description for defaults.
	 * @return this object. For method chaining.
	 */
	public final ReportGenerator setSourceEncoding(final String sourceEncoding) {
		this.sourceEncoding = sourceEncoding == null ? DEFAULT_ENCODING
				: sourceEncoding;
		return this;
	}

	/**
	 * Returns the list of source roots searched for source files matching the
	 * classes processed. This is the path to the top of a Java source tree such
	 * as "<code>src/main/java</code>".
	 * 
	 * @return the list of source roots searched.
	 */
	public final List<File> getSourceRoots() {
		return sourceRoots;
	}

	/**
	 * Set the list of source roots searched for source files matching the
	 * classes processed. This is the path to the top of a Java source tree such
	 * as "<code>src/main/java</code>".
	 * 
	 * @param sourceRoots
	 *            the list of source roots searched.
	 * @return this object. For method chaining.
	 */
	public final ReportGenerator setSourceRoots(final List<File> sourceRoots) {
		this.sourceRoots = sourceRoots == null ? DEFAULT_SOURCE_DIR
				: sourceRoots;
		return this;
	}

	/**
	 * Returns the report output encoding used.
	 * 
	 * @return the report output encoding used.
	 */
	public final String getOutputEncoding() {
		return outputEncoding;
	}

	/**
	 * Sets the report output encoding used..
	 * 
	 * @param outputEncoding
	 *            the new report output encoding. If <code>null</code> returns
	 *            to the default value. See class description for defaults.
	 * @return this object. For method chaining.
	 */
	public final ReportGenerator setOutputEncoding(final String outputEncoding) {
		this.outputEncoding = outputEncoding == null ? DEFAULT_ENCODING
				: outputEncoding;
		return this;
	}

	/**
	 * Returns the report output directory used.
	 * 
	 * @return the report output directory used.
	 */
	public final File getReportOutputDirectory() {
		return reportOutputDirectory;
	}

	/**
	 * Sets the report output directory used.
	 * 
	 * @param reportOutputDirectory
	 *            the new report output directory. If <code>null</code> returns
	 *            to the default value. See class description for defaults.
	 * @return this object. For method chaining.
	 */
	public final ReportGenerator setReportOutputDirectory(
			final File reportOutputDirectory) {
		this.reportOutputDirectory = reportOutputDirectory == null ? DEFAULT_OUTPUT_DIR
				: reportOutputDirectory;
		return this;
	}

	/**
	 * Returns the list of class paths match to execution data. All class files
	 * in all paths are processed. Each values is: a directory similar to a
	 * classpath, a class file, a jar, or a zip file.
	 * 
	 * @return the list of class paths.
	 */
	public final List<File> getClassesDirectories() {
		return classesDirectories;
	}

	/**
	 * Set the list of class paths match to execution data. All class files in
	 * all paths are processed. Each values is: a directory similar to a
	 * classpath, a class file, a jar, or a zip file. If <code>null</code>
	 * returns to the default value. See class description for defaults.
	 * 
	 * @param classesDirectory
	 *            the new list of class paths.
	 * @return this object. For method chaining.
	 */
	public final ReportGenerator setClassesDirectories(
			final List<File> classesDirectory) {
		this.classesDirectories = classesDirectory == null ? DEFAULT_CLASSES_DIRECTORIES
				: classesDirectory;
		return this;
	}

	/**
	 * Returns the locale used for report generation.
	 * 
	 * @return the locale used for report generation.
	 */
	public final Locale getLocale() {
		return locale;
	}

	/**
	 * Set the locale used for report generation. If <code>null</code> returns
	 * to the default value. See class description for defaults.
	 * 
	 * @param locale
	 *            the new locale.
	 * @return this object. For method chaining.
	 */
	public final ReportGenerator setLocale(final Locale locale) {
		this.locale = locale == null ? Locale.getDefault() : locale;
		return this;
	}

	/**
	 * Returns {@code true} if E-BigO style analysis of the execution data is
	 * enabled.
	 * 
	 * @return {@code true} if E-BigO style analysis of the execution data is
	 *         enabled.
	 */
	public final boolean isEBigOEnabled() {
		return eBigOEnabled;
	}

	/**
	 * Enable E-BigO style analysis of the execution data using the default
	 * E-BigO attribute.
	 * 
	 * @param enabled
	 *            if {@code true}-BigO style analysis of the execution data is
	 *            used with the default attribute.
	 * @return this object. For method chaining.
	 */
	public final ReportGenerator setEBigOEnabled(final boolean enabled) {
		return setEBigOAttribute(enabled ? WorkloadAttributeMapBuilder.DEFAULT_ATTRIBUTE
				: null);
	}

	/**
	 * Returns E-BigO attribute used for analysis
	 * 
	 * @return the E-BigO attribute used for analysis. If {@code null} E-BigO
	 *         analysis is disabled.
	 */
	public final String getEBigOAttribute() {
		return eBigOAttribute;
	}

	/**
	 * Sets E-BigO attribute used for analysis
	 * 
	 * @param eBigOAttribute
	 *            the E-BigO attribute used for analysis. If {@code null} E-BigO
	 *            analysis is disabled; Otherwise, setting this values enables
	 *            E-BigO analysis.
	 * @return this object. For method chaining.
	 */
	public final ReportGenerator setEBigOAttribute(final String eBigOAttribute) {
		eBigOEnabled = eBigOAttribute != null;
		this.eBigOAttribute = eBigOAttribute;
		return this;
	}

	/**
	 * Implementation specific loading of the execution data. As Ant and Maven
	 * have different styles of specifying which execution data files to load
	 * and from where, this operation is delegated to the sub-class.
	 * 
	 * @param fetcher
	 *            the fetcher style to use for execution data load
	 * 
	 * @throws IOException
	 *             on any failure to load execution data
	 */
	protected abstract void loadExecutionData(ICoverageFetcherStyle fetcher)
			throws IOException;

	/**
	 * Implementation specific invocations of the class analyzer. As different
	 * users have different styles of specifying which class files in the
	 * classes directories to analyze, this operation is delegated to the
	 * sub-class.
	 * 
	 * @param analyzer
	 *            the analyzer to use for analysis of selected class files.
	 * @throws IOException
	 *             on any failure to read or analyze class files.
	 */
	protected abstract void analyzeExecutionData(final IAnalyzer analyzer)
			throws IOException;

	/**
	 * Implementation specific analysis of readiness to generate the report.
	 * This may include things such as execution data exists. Report generation
	 * is silently skipped by the generator if this method returns
	 * <code>false</code>. As different users of this have different skip
	 * condition, this operation is delegated to the sub-class.
	 * 
	 * @return <code>true</code> if the report can be generated; Otherwise,
	 *         generation is silently skipped.
	 */
	protected abstract boolean canGenerateReport();

	/**
	 * This method is to directly invoke the full report generation process.
	 * 
	 * @throws IOException
	 *             on any failure to read execution data, analyze classes, or
	 *             write the report.
	 */
	public final void execute() throws IOException {
		final IBundleCoverage bundle = prepReport();
		if (bundle == null) {
			return;
		}

		try {
			executeReport(bundle);
		} catch (final Exception e) {
			IOException ioe;
			if (e instanceof IOException) {
				ioe = (IOException) e;
			} else {
				ioe = new IOException("An error has occurred in " + getName()
						+ " report generation output.");
				ioe.initCause(e);
			}
			throw ioe;
		}
	}

	/**
	 * This method is to invoke the report generation process without producing
	 * any output.
	 * 
	 * @return the coverage bundle that has the report information that would be
	 *         used to output the report.
	 * @throws IOException
	 *             on any failure to generate the bundle
	 */
	public IBundleCoverage prepReport() throws IOException {
		if (!canGenerateReport()) {
			return null;
		}

		try {
			this.dataFetcher = !eBigOEnabled ? new DefaultCoverageFetcherStyle()
					: new EBigOCoverageFetcherStyle(eBigOAttribute);
			loadExecutionData(this.dataFetcher);
			final CoverageBuilder builder = dataFetcher.newCoverageBuilder();
			final IAnalyzer analyzer = dataFetcher.newAnalyzer(builder);
			analyzeExecutionData(analyzer);
			final IBundleCoverage bundle = builder.getBundle(getName());
			bundle.logCoverageInfo(builder.getNoMatchClasses(),
					new DirectLoggingBridge());

			return bundle;

		} catch (final Exception e) {
			IOException ioe;
			if (e instanceof IOException) {
				ioe = (IOException) e;
			} else {
				ioe = new IOException("An error has occurred in " + getName()
						+ " report generation setup.");
				ioe.initCause(e);
			}
			throw ioe;
		}
	}

	private void executeReport(final IBundleCoverage bundle) throws IOException {
		final IReportVisitor visitor = createVisitor();
		visitor.visitInfo(dataFetcher.getSessionInfoStore().getInfos(),
				dataFetcher.getExecutionDataStore().getContents());
		final SourceFileCollection locator = new SourceFileCollection(
				getSourceRoots(), getSourceEncoding());
		bundle.logMissingDebugInformation(log);
		visitor.visitBundle(bundle, locator);
		visitor.visitEnd();
	}

	private IReportVisitor createVisitor() throws IOException {

		getReportOutputDirectory().mkdirs();

		final List<IReportVisitor> visitors = new ArrayList<IReportVisitor>();
		final XMLFormatter xmlFormatter = new XMLFormatter();
		xmlFormatter.setOutputEncoding(getOutputEncoding());
		visitors.add(xmlFormatter.createVisitor(new FileOutputStream(new File(
				getReportOutputDirectory(), "jacoco.xml"))));

		final CSVFormatter csvFormatter = new CSVFormatter();
		csvFormatter.setOutputEncoding(getOutputEncoding());
		visitors.add(csvFormatter.createVisitor(new FileOutputStream(new File(
				getReportOutputDirectory(), "jacoco.csv"))));

		final HTMLFormatter htmlFormatter = new HTMLFormatter();
		htmlFormatter.setOutputEncoding(getOutputEncoding());
		htmlFormatter.setLocale(getLocale());
		visitors.add(htmlFormatter.createVisitor(new FileMultiReportOutput(
				getReportOutputDirectory())));

		return new MultiReportVisitor(visitors);
	}

	private static class SourceFileCollection implements ISourceFileLocator {

		private final List<File> sourceRoots;
		private final String encoding;

		public SourceFileCollection(final List<File> sourceRoots,
				final String encoding) {
			this.sourceRoots = sourceRoots;
			this.encoding = encoding;
		}

		public Reader getSourceFile(final String packageName,
				final String fileName) throws IOException {
			final String r;
			if (packageName.length() > 0) {
				r = packageName + '/' + fileName;
			} else {
				r = fileName;
			}
			for (final File sourceRoot : sourceRoots) {
				final File file = new File(sourceRoot, r);
				if (file.exists() && file.isFile()) {
					return new InputStreamReader(new FileInputStream(file),
							encoding);
				}
			}
			return null;
		}

		public int getTabWidth() {
			return 4;
		}
	}

	private static class DirectLoggingBridge implements LoggingBridge {

		public void info(final String msg) {
			System.out.println("INFO: " + msg);
		}

		public void warning(final String msg) {
			System.err.println("WARN: " + msg);
		}

		public void severe(final String msg) {
			System.err.println("ERROR: " + msg);
		}
	}

}